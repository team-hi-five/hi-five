import "./ChildCss/ChildClassPage.css";
import useGameStore from "../../store/gameStore";
import { limitGamedata } from "../../api/childGameContent";
import { useEffect, useState, useRef, useCallback } from "react";
import { Card } from "primereact/card";
import * as faceapi from "face-api.js";
import stringSimilarity from "string-similarity";
import Swal from "sweetalert2";
import { BsStopBtnFill } from "react-icons/bs";
import { OpenVidu } from "openvidu-browser";
import api from "../../api/api";
// Í∏∞Ï°¥ ChildVideoScreen ÎåÄÏã† ÏùºÎ∞ò <video> ÌÉúÍ∑∏Î°ú ÎåÄÏ≤¥
// import ChildVideoScreen from "../../components/OpenViduSession/ChildVideoScreen";
import CounselorCamWithChild from "../../components/OpenViduSession/CounselorCamWithChild";

function ChildReviewGamePage() {
  console.log("[ChildReviewGamePage] Component mounted");

  // Í≤åÏûÑ ÎèôÏòÅÏÉÅ Í¥ÄÎ†® videoRef (ÏôºÏ™Ω Í≤åÏûÑÏòÅÏÉÅ)
  const videoRef = useRef(null);
  // ÏïÑÎèô ÏõπÏ∫† Ïä§Ìä∏Î¶ºÏö© ref (ÏùºÎ∞ò ÏõπÏ∫† ÏòÅÏÉÅ, OpenVidu ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå)
  const childWebcamRef = useRef(null);
  // OpenVidu ÌôîÎ©¥ Í≥µÏú†Ïö© ref (ÏïÑÎèôÏù¥ ÌôîÎ©¥ Í≥µÏú† Ïãú ÏÜ°Ï∂ú)
  // (ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶ºÏùÄ ÌôîÎ©¥ Í≥µÏú† Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú ÏÉùÏÑ±)
  const [screenSubscriber, setScreenSubscriber] = useState(null);

  // OpenVidu ÏÑ∏ÏÖò Î∞è Í¥ÄÎ†® ÏÉÅÌÉú (Ïò§ÏßÅ ÌôîÎ©¥ Í≥µÏú†Ïö©)
  const [session, setSession] = useState(null);
  // (ÏïÑÎèôÏùò ÏõπÏ∫†ÏùÄ ÏùºÎ∞ò Ïä§Ìä∏Î¶ºÏúºÎ°ú Ï≤òÎ¶¨ÌïòÎØÄÎ°ú publisher ÏÉÅÌÉúÎäî Ï†úÍ±∞)
  // const [publisher, setPublisher] = useState(null);

  // Í∏∞ÌÉÄ Í≤åÏûÑ Î∞è Î∂ÑÏÑù Í¥ÄÎ†® ÏÉÅÌÉúÎì§
  const webcamRef = useRef(null); // face-api Î∂ÑÏÑùÏö© (ÌïÑÏöî Ïãú ÏÇ¨Ïö©)
  const analysisIntervalRef = useRef(null);
  const analysisDataRef = useRef([]);
  const childId = sessionStorage.getItem("childId");
  const { setChapterAndStage, getCurrentGameData } = useGameStore();
  const [gameState, setGameState] = useState(null);
  const [gameIdData, setGameIdData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [currentGameData, setCurrentGameData] = useState(null);
  const [phase, setPhase] = useState("video");
  const [showContent, setShowContent] = useState(false);
  const [currentVideoIndex, setCurrentVideoIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [faceResult, setFaceResult] = useState(null);
  const [voiceResult, setVoiceResult] = useState(null);
  const [analysisCycle, setAnalysisCycle] = useState(1);

  // OpenVidu Í∞ùÏ≤¥
  const OV = useRef(new OpenVidu());

  // --- 0. Ïò§ÌîàÎπÑÎëê ÌÜ†ÌÅ∞ Î∞õÍ∏∞ ---
  async function getToken() {
    try {
      const response = await api.post("/session/join", {
        type: "game",
        childId,
      });
      console.log("ÌÜ†ÌÅ∞!:", response.data);
      return response.data;
    } catch (error) {
      console.error("ÌÜ†ÌÅ∞ ÏöîÏ≤≠ Ïã§Ìå®:", error);
      throw error;
    }
  }

  // --- 1. OpenVidu ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî ---
  // Ïó¨Í∏∞ÏÑúÎäî ÌôîÎ©¥ Í≥µÏú† Í∏∞Îä•ÏóêÎßå ÏÇ¨Ïö©Ìï† ÏÑ∏ÏÖòÏùÑ Ïó∞Í≤∞Ìï©ÎãàÎã§.
  const initializeSession = useCallback(async () => {
    try {
      const sessionInstance = OV.current.initSession();

      // ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶ºÎßå Íµ¨ÎèÖÌïòÎèÑÎ°ù Ï≤òÎ¶¨
      sessionInstance.on("streamCreated", (event) => {
        const videoSource = (event.stream.videoSource || "").toLowerCase();
        console.log("[ChildReviewGamePage] streamCreated Ïù¥Î≤§Ìä∏:", event);
        if (videoSource === "screen") {
          // ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶ºÎßå Íµ¨ÎèÖ (ÏïÑÎèô Ï∏°ÏóêÏÑúÎäî ÌôîÎ©¥ Í≥µÏú†Î•º Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú Ï£ºÏÑù Ï≤òÎ¶¨ Í∞ÄÎä•)
          // ÌïòÏßÄÎßå ÏÉÅÎã¥ÏÇ¨ÏóêÏÑúÎäî Ïù¥ Ïä§Ìä∏Î¶ºÏùÑ Íµ¨ÎèÖÌïòÍ≤å Îê©ÎãàÎã§.
          // Ïó¨Í∏∞ÏÑúÎäî Î°úÍ∑∏Î°úÎßå ÎÇ®ÍπÅÎãàÎã§.
          console.log("[ChildReviewGamePage] ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶º Í∞êÏßÄ:", event.stream.streamId);
        }
      });

      sessionInstance.on("streamDestroyed", (event) => {
        console.log("[ChildReviewGamePage] streamDestroyed:", event);
        // ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶ºÏù¥ Ï¢ÖÎ£åÎêòÎ©¥ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        setScreenSubscriber(null);
      });

      const token = await getToken();
      await sessionInstance.connect(token);
      setSession(sessionInstance);

      // **Ï§ëÏöî**: ÏïÑÎèôÏùò ÏõπÏ∫† ÏòÅÏÉÅÏùÄ OpenViduÎ•º ÌÜµÌï¥ publishÌïòÏßÄ ÏïäÏäµÎãàÎã§.
      // Îî∞ÎùºÏÑú Ïó¨Í∏∞ÏÑúÎäî publish ÏΩîÎìúÎ•º Ï†úÍ±∞Ìï©ÎãàÎã§.
      // ÌôîÎ©¥ Í≥µÏú†Îäî Î≥ÑÎèÑ startScreenShare Ìï®ÏàòÏóêÏÑú Ï≤òÎ¶¨Îê©ÎãàÎã§.
    } catch (error) {
      console.error("ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", error);
    }
  }, []);

  // --- 2. ÌôîÎ©¥ Í≥µÏú† ÏãúÏûë Ìï®Ïàò ---
  const createScreenShareStream = async () => {
    try {
      console.log("1. ÌôîÎ©¥ Í≥µÏú† ÏãúÏûë ÏãúÎèÑ...");
      if (screenSubscriber) {
        console.log("üìå Ïù¥ÎØ∏ ÌôîÎ©¥ Í≥µÏú† Ï§ëÏûÖÎãàÎã§.");
        return;
      }

      const displayStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true,
      });

      const newScreenPublisher = OV.current.initPublisher(undefined, {
        videoSource: "screen",
        audioSource: true,
        publishVideo: true,
        mirror: false,
      });

      await session.publish(newScreenPublisher);
      setScreenSubscriber(newScreenPublisher);

      newScreenPublisher.stream.getVideoTracks()[0].addEventListener("ended", () => {
        console.log("ÏÇ¨Ïö©ÏûêÍ∞Ä ÌôîÎ©¥ Í≥µÏú†Î•º Ï§ëÎã®Ìï®");
        session.unpublish(newScreenPublisher);
        setScreenSubscriber(null);
      });
    } catch (error) {
      console.error("‚ùå ÌôîÎ©¥ Í≥µÏú† Ï§ë Ïò§Î•ò:", error);
      setScreenSubscriber(null);
    }
  };

  const startScreenShare = async () => {
    await createScreenShareStream();
  };

  // --- 3. Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú OpenVidu ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî ---
  useEffect(() => {
    initializeSession();
    return () => {
      if (session) session.disconnect();
    };
  }, [initializeSession]);

  // --- 4. ÏïÑÎèô ÏùºÎ∞ò ÏõπÏ∫† Ïä§Ìä∏Î¶º ÏãúÏûë (OpenVidu ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå) ---
  useEffect(() => {
    const startChildWebcam = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        console.log("[startChildWebcam] ÏõπÏ∫† Ïä§Ìä∏Î¶º ÌöçÎìù:", stream);
        if (childWebcamRef.current) {
          childWebcamRef.current.srcObject = stream;
          childWebcamRef.current.play();
          console.log("[startChildWebcam] ÏõπÏ∫† ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÏûë");
        }
      } catch (err) {
        console.error("[startChildWebcam] ÏõπÏ∫† ÏãúÏûë Ïã§Ìå®:", err);
      }
    };
    startChildWebcam();
  }, []);

  // --- Í∏∞Ï°¥ API Ìò∏Ï∂ú, face-api Î™®Îç∏ Î°úÎìú, Î∂ÑÏÑù Í¥ÄÎ†® useEffect Îì± ---
  useEffect(() => {
    const fetchLimitData = async () => {
      console.log("[fetchLimitData] Ìò∏Ï∂úÎê® - childId:", childId);
      try {
        const data = await limitGamedata(childId);
        console.log("[fetchLimitData] API Ìò∏Ï∂ú Í≤∞Í≥º:", data);
        setGameIdData("Í∞ÄÏ†∏Ïò® Ï†ïÎ≥¥", data);
        if (data) {
          await useGameStore.getState().fetchChapterData(data.chapter);
          setChapterAndStage(data.chapter, data.stage);
          const currentState = useGameStore.getState();
          console.log("[fetchLimitData] ÌòÑÏû¨ Í≤åÏûÑ ÏÉÅÌÉú:", currentState);
          setGameState(currentState);
        }
        const gameData = useGameStore.getState().getCurrentGameData();
        console.log("[fetchLimitData] ÌòÑÏû¨ Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞:", gameData);
        setCurrentGameData(gameData);
      } catch (error) {
        console.error("[fetchLimitData] Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:", error);
      } finally {
        setIsLoading(false);
        console.log("[fetchLimitData] Î°úÎî© ÏôÑÎ£å - isLoading:", false);
      }
    };
    fetchLimitData();
  }, [childId]);

  useEffect(() => {
    if (currentGameData) {
      console.log("[useEffect - currentGameData] ÏóÖÎç∞Ïù¥Ìä∏Îêú currentGameData:", currentGameData);
    }
  }, [currentGameData]);

  useEffect(() => {
    const loadModels = async () => {
      console.log("[loadModels] Ìò∏Ï∂úÎê® - face-api Î™®Îç∏ Î°úÎìú ÏãúÏûë");
      const MODEL_URL = "/models";
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
        faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
      ]);
      console.log("[loadModels] face-api Î™®Îç∏ Î°úÎìú ÏôÑÎ£å");
    };
    loadModels();
  }, []);

  useEffect(() => {
    const startWebcamForAnalysis = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
        if (webcamRef.current) {
          webcamRef.current.srcObject = stream;
          webcamRef.current.play();
        }
      } catch (err) {
        console.error("[startWebcamForAnalysis] ÏõπÏ∫† ÏãúÏûë Ïã§Ìå®:", err);
      }
    };
    startWebcamForAnalysis();
  }, []);

  useEffect(() => {
    console.log("[useEffect - ÏãúÏûë Î™®Îã¨] Ìò∏Ï∂úÎê® - ÏãúÏûë Î≤ÑÌäº Î™®Îã¨ Ïã§Ìñâ");
    Swal.fire({
      title: "Í∞êÏ†ïÏïÑ! Í∞ôÏù¥ Í≥µÎ∂ÄÌï¥ Î≥ºÍπå?",
      imageUrl: "/child/character/againCh.png",
      imageWidth: 200,
      imageHeight: 200,
      showConfirmButton: true,
    }).then((result) => {
      console.log("[useEffect - ÏãúÏûë Î™®Îã¨] Swal Í≤∞Í≥º:", result);
      if (result.isConfirmed) {
        setShowContent(true);
      }
    });
  }, []);

  useEffect(() => {
    if (phase === "video" && currentGameData && videoRef.current && showContent) {
      videoRef.current.play()
          .then(() => console.log("ÏÉà Îã®Ïõê ÎèôÏòÅÏÉÅ ÏûêÎèô Ïû¨ÏÉùÎê®"))
          .catch((error) => console.error("ÏûêÎèô Ïû¨ÏÉù Ïã§Ìå®:", error));
    }
  }, [phase, currentGameData, showContent]);

  // Ïù¥Ìïò Î∂ÑÏÑù Í¥ÄÎ†® ÏΩîÎìú(ÎèôÏãú Î∂ÑÏÑù, ÌëúÏ†ï Î∂ÑÏÑù, ÏùåÏÑ± Î∂ÑÏÑù) Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ
  const handleVideoEnd = () => {
    console.log("[handleVideoEnd] Ìò∏Ï∂úÎê® - ÎπÑÎîîÏò§ Ï¢ÖÎ£å, phase Î≥ÄÍ≤Ω -> analysisModal");
    setPhase("analysisModal");
  };

  const computeAverageEmotion = (data) => {
    console.log("[computeAverageEmotion] Ìò∏Ï∂úÎê® - Í∞êÏ†ï Îç∞Ïù¥ÌÑ∞ ÌèâÍ∑† Í≥ÑÏÇ∞ ÏãúÏûë");
    let sum = { neutral: 0, happy: 0, sad: 0, angry: 0, fearful: 0, disgusted: 0, surprised: 0 };
    let count = 0;
    data.forEach((item, dataIndex) => {
      item.emotions.forEach((emotionObj, emotionIndex) => {
        Object.keys(sum).forEach((key) => {
          sum[key] += emotionObj[key] || 0;
        });
        count++;
      });
    });
    if (count === 0) {
      console.log("[computeAverageEmotion] Í∞êÏßÄÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå");
      return null;
    }
    let avg = {};
    Object.keys(sum).forEach((key) => {
      avg[key] = sum[key] / count;
    });
    console.log("[computeAverageEmotion] Í≥ÑÏÇ∞Îêú ÌèâÍ∑† Í∞êÏ†ï:", avg);
    return avg;
  };

  const runConcurrentAnalysis = async () => {
    console.log("[runConcurrentAnalysis] Ìò∏Ï∂úÎê® - ÎèôÏãú Î∂ÑÏÑù ÏãúÏûë (ÌëúÏ†ï+ÏùåÏÑ±)");
    const facePromise = new Promise((resolve) => {
      console.log("[facePromise] ÌëúÏ†ï Î∂ÑÏÑù ÏãúÏûë: 9Ï¥àÍ∞Ñ Î∂ÑÏÑù ÏãúÏûë");
      analysisDataRef.current = [];
      const intervalId = setInterval(async () => {
        if (webcamRef.current) {
          const detections = await faceapi
              .detectAllFaces(webcamRef.current, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks()
              .withFaceExpressions();
          console.log("[facePromise] Í∞êÏßÄ Í≤∞Í≥º:", detections);
          if (detections.length > 0) {
            const emotions = detections.map((det) => det.expressions);
            analysisDataRef.current.push({ timestamp: new Date().toISOString(), emotions });
            console.log("[facePromise] ÌòÑÏû¨ Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞:", analysisDataRef.current);
          }
        }
      }, 100);
      analysisIntervalRef.current = intervalId;
      setTimeout(() => {
        clearInterval(analysisIntervalRef.current);
        analysisIntervalRef.current = null;
        console.log("[facePromise] 9Ï¥à Î∂ÑÏÑù Ï¢ÖÎ£å, Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞:", analysisDataRef.current);
        const avgEmotion = computeAverageEmotion(analysisDataRef.current);
        if (!avgEmotion) {
          resolve("ÌëúÏ†ï Î∂ÑÏÑù Ïã§Ìå®");
          return;
        }
        const candidates = ["happy", "sad", "angry", "fearful", "surprised"];
        const candidateAverages = candidates.map((emotion) => ({
          emotion,
          value: avgEmotion[emotion] || 0,
        }));
        candidateAverages.sort((a, b) => b.value - a.value);
        const bestEmotion = candidateAverages[0].emotion;
        const expectedEmotions = ["happy", "sad", "angry", "fearful", "surprised"];
        const expectedEmotion = expectedEmotions[currentVideoIndex] || "ÏóÜÏùå";
        const resultMsg =
            bestEmotion === expectedEmotion
                ? `Ï†ïÎãµÏûÖÎãàÎã§! ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º: ${bestEmotion}`
                : `Ïò§ÎãµÏûÖÎãàÎã§! ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º: ${bestEmotion} (ÏòàÏÉÅ: ${expectedEmotion})`;
        console.log("[facePromise] Î∂ÑÏÑù Í≤∞Í≥º Î©îÏãúÏßÄ:", resultMsg);
        resolve(resultMsg);
      }, 9000);
    });

    const voicePromise = new Promise((resolve, reject) => {
      console.log("[voicePromise] ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûë");
      if (!("webkitSpeechRecognition" in window) && !("SpeechRecognition" in window)) {
        console.error("[voicePromise] Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Speech RecognitionÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        reject("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Speech RecognitionÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        return;
      }
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      recognition.lang = "ko-KR";
      recognition.interimResults = false;
      recognition.continuous = false;
      const voiceTimeout = setTimeout(() => {
        recognition.abort();
        console.log("[voicePromise] ÏùåÏÑ± Ïù∏Ïãù ÏãúÍ∞Ñ Ï¥àÍ≥º, Ï¢ÖÎ£åÎê®");
        resolve("ÏùåÏÑ± Ïù∏Ïãù ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§.");
      }, 9000);
      recognition.onresult = (event) => {
        clearTimeout(voiceTimeout);
        console.log("[voicePromise] ÏùåÏÑ± Ïù∏Ïãù Í≤∞Í≥º Ïù¥Î≤§Ìä∏:", event);
        let finalResult = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalResult += event.results[i][0].transcript;
          }
        }
        console.log("[voicePromise] ÏµúÏ¢Ö ÏùåÏÑ± Í≤∞Í≥º:", finalResult);
        const optionsArray = currentGameData.options;
        const bestMatch = stringSimilarity.findBestMatch(finalResult, optionsArray);
        const bestOptionIndex = bestMatch.bestMatchIndex;
        const voiceMsg =
            bestOptionIndex === currentGameData.answer - 1
                ? `Ï†ïÎãµÏûÖÎãàÎã§! ÏÑ†ÌÉùÌïú ÏòµÏÖòÏùÄ ${optionsArray[bestOptionIndex]}ÏûÖÎãàÎã§.`
                : `Ïò§ÎãµÏûÖÎãàÎã§! ÏÑ†ÌÉùÌïú ÏòµÏÖòÏùÄ ${optionsArray[bestOptionIndex]}ÏûÖÎãàÎã§.`;
        console.log("[voicePromise] ÏùåÏÑ± Î∂ÑÏÑù Í≤∞Í≥º Î©îÏãúÏßÄ:", voiceMsg);
        resolve(voiceMsg);
      };
      recognition.onerror = (event) => {
        clearTimeout(voiceTimeout);
        console.error("[voicePromise] ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò:", event.error);
        resolve("ÏùåÏÑ± Ïù∏Ïãù Ïã§Ìå®");
      };
      recognition.start();
      console.log("[voicePromise] ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûëÎê®");
    });

    try {
      const [faceMsg, voiceMsg] = await Promise.all([facePromise, voicePromise]);
      console.log("[runConcurrentAnalysis] ÎèôÏãú Î∂ÑÏÑù ÏôÑÎ£å - faceMsg:", faceMsg, ", voiceMsg:", voiceMsg);
      setFaceResult(faceMsg);
      setVoiceResult(voiceMsg);
      setPhase("analysisResult");
      console.log("[runConcurrentAnalysis] phase Î≥ÄÍ≤Ω -> analysisResult");
    } catch (error) {
      console.error("[runConcurrentAnalysis] ÎèôÏãú Î∂ÑÏÑù Ïò§Î•ò:", error);
    }
  };

  const runFaceAnalysis = async () => {
    console.log("[runFaceAnalysis] Ìò∏Ï∂úÎê® - ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë (ÌëúÏ†ï Ïó∞Ïäµ)");
    const faceMsg = await new Promise((resolve) => {
      console.log("[faceAnalysis] ÌëúÏ†ï Î∂ÑÏÑù ÏãúÏûë: 9Ï¥àÍ∞Ñ Î∂ÑÏÑù ÏãúÏûë");
      analysisDataRef.current = [];
      const intervalId = setInterval(async () => {
        if (webcamRef.current) {
          const detections = await faceapi
              .detectAllFaces(webcamRef.current, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks()
              .withFaceExpressions();
          console.log("[faceAnalysis] Í∞êÏßÄ Í≤∞Í≥º:", detections);
          if (detections.length > 0) {
            const emotions = detections.map((det) => det.expressions);
            analysisDataRef.current.push({
              timestamp: new Date().toISOString(),
              emotions,
            });
            console.log("[faceAnalysis] ÌòÑÏû¨ Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞:", analysisDataRef.current);
          }
        }
      }, 100);
      analysisIntervalRef.current = intervalId;
      setTimeout(() => {
        clearInterval(analysisIntervalRef.current);
        analysisIntervalRef.current = null;
        console.log("[faceAnalysis] 9Ï¥à Î∂ÑÏÑù Ï¢ÖÎ£å, Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞:", analysisDataRef.current);
        const avgEmotion = computeAverageEmotion(analysisDataRef.current);
        if (!avgEmotion) {
          resolve("ÌëúÏ†ï Î∂ÑÏÑù Ïã§Ìå®");
          return;
        }
        const candidates = ["happy", "sad", "angry", "fearful", "surprised"];
        const candidateAverages = candidates.map((emotion) => ({
          emotion,
          value: avgEmotion[emotion] || 0,
        }));
        candidateAverages.sort((a, b) => b.value - a.value);
        const bestEmotion = candidateAverages[0].emotion;
        const expectedEmotions = ["happy", "sad", "angry", "fearful", "surprised"];
        const expectedEmotion = expectedEmotions[currentVideoIndex] || "ÏóÜÏùå";
        const resultMsg =
            bestEmotion === expectedEmotion
                ? `Ï†ïÎãµÏûÖÎãàÎã§! ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º: ${bestEmotion}`
                : `Ïò§ÎãµÏûÖÎãàÎã§! ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º: ${bestEmotion} (ÏòàÏÉÅ: ${expectedEmotion})`;
        console.log("[faceAnalysis] Î∂ÑÏÑù Í≤∞Í≥º Î©îÏãúÏßÄ:", resultMsg);
        resolve(resultMsg);
      }, 5000);
    });
    setFaceResult(faceMsg);
    setPhase("analysisResult");
    console.log("[runFaceAnalysis] ÏñºÍµ¥ Î∂ÑÏÑù ÏôÑÎ£å, faceResult:", faceMsg);
  };

  const runVoiceAnalysis = async () => {
    console.log("[runVoiceAnalysis] Ìò∏Ï∂úÎê® - ÏùåÏÑ± Î∂ÑÏÑù ÏãúÏûë (Îßê Ïó∞Ïäµ)");
    const voiceMsg = await new Promise((resolve, reject) => {
      if (!("webkitSpeechRecognition" in window) && !("SpeechRecognition" in window)) {
        console.error("[runVoiceAnalysis] Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Speech RecognitionÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        reject("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Speech RecognitionÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        return;
      }
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      recognition.lang = "ko-KR";
      recognition.interimResults = false;
      recognition.continuous = false;
      const voiceTimeout = setTimeout(() => {
        recognition.abort();
        console.log("[runVoiceAnalysis] ÏùåÏÑ± Ïù∏Ïãù ÏãúÍ∞Ñ Ï¥àÍ≥º, Ï¢ÖÎ£åÎê®");
        resolve("ÏùåÏÑ± Ïù∏Ïãù ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§.");
      }, 5000);
      recognition.onresult = (event) => {
        clearTimeout(voiceTimeout);
        console.log("[runVoiceAnalysis] ÏùåÏÑ± Ïù∏Ïãù Í≤∞Í≥º Ïù¥Î≤§Ìä∏:", event);
        let finalResult = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalResult += event.results[i][0].transcript;
          }
        }
        console.log("[runVoiceAnalysis] ÏµúÏ¢Ö ÏùåÏÑ± Í≤∞Í≥º:", finalResult);
        const optionsArray = currentGameData.options;
        const bestMatch = stringSimilarity.findBestMatch(finalResult, optionsArray);
        const bestOptionIndex = bestMatch.bestMatchIndex;
        const resultMsg =
            bestOptionIndex === currentGameData.answer - 1
                ? `Ï†ïÎãµÏûÖÎãàÎã§! ÏÑ†ÌÉùÌïú ÏòµÏÖòÏùÄ ${optionsArray[bestOptionIndex]}ÏûÖÎãàÎã§.`
                : `Ïò§ÎãµÏûÖÎãàÎã§! ÏÑ†ÌÉùÌïú ÏòµÏÖòÏùÄ ${optionsArray[bestOptionIndex]}ÏûÖÎãàÎã§.`;
        console.log("[runVoiceAnalysis] ÏùåÏÑ± Î∂ÑÏÑù Í≤∞Í≥º Î©îÏãúÏßÄ:", resultMsg);
        resolve(resultMsg);
      };
      recognition.onerror = (event) => {
        clearTimeout(voiceTimeout);
        console.error("[runVoiceAnalysis] ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò:", event.error);
        resolve("ÏùåÏÑ± Ïù∏Ïãù Ïã§Ìå®");
      };
      recognition.start();
      console.log("[runVoiceAnalysis] ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûëÎê®");
    });
    setVoiceResult(voiceMsg);
    setPhase("analysisResult");
    console.log("[runVoiceAnalysis] ÏùåÏÑ± Î∂ÑÏÑù ÏôÑÎ£å, voiceResult:", voiceMsg);
  };

  useEffect(() => {
    if (phase === "analysisResult") {
      console.log("[useEffect - analysisResult] phase:", phase, "analysisCycle:", analysisCycle);
      if (analysisCycle === 1 || analysisCycle === 2) {
        Swal.fire({
          title: `Î∂ÑÏÑù Í≤∞Í≥ºÏòàÏöî!`,
          html: `
            <p>ÌëúÏ†ï Î∂ÑÏÑù: ${faceResult}</p>
            <p>ÏùåÏÑ± Ïù∏Ïãù: ${voiceResult}</p>
          `,
          imageUrl: "/child/character/againCh.png",
          imageWidth: 200,
          imageHeight: 200,
          showConfirmButton: true,
          confirmButtonText: "Îã§ÏùåÏúºÎ°ú"
        }).then((result) => {
          console.log("[useEffect - analysisResult] concurrent analysis modal result:", result);
          if (result.isConfirmed) {
            if (analysisCycle === 1) {
              if (faceResult.includes("Ï†ïÎãµ") && voiceResult.includes("Ï†ïÎãµ")) {
                Swal.fire({
                  title: "Ïù¥Ï†ú ÌëúÏ†ï Ïó∞ÏäµÏùÑ Ìï¥Î≥ºÍπåÏöî?",
                  text: "Í±∞Ïö∏ÏùÑ Î≥¥Î©¥ÏÑú Ï≤úÏ≤úÌûà Îî∞ÎùºÌï¥Î≥¥ÏÑ∏Ïöî!",
                  imageUrl: "/child/character/againCh.png",
                  imageWidth: 200,
                  imageHeight: 200,
                  timer: 3000,
                  showConfirmButton: false
                }).then(() => {
                  console.log("[useEffect - analysisResult] ÌëúÏ†ï Ïó∞Ïäµ Î™®Îã¨ ÏôÑÎ£å, cycle Î≥ÄÍ≤Ω -> 3");
                  setAnalysisCycle(3);
                  setFaceResult(null);
                  setVoiceResult(null);
                  setPhase("analysisModal");
                });
              } else {
                Swal.fire({
                  title: "Ìïú Î≤à Îçî Ïó∞ÏäµÌï¥Î≥ºÍπåÏöî?",
                  text: "Îã§Ïãú Ìïú Î≤à ÌëúÏ†ïÍ≥º ÎßêÏùÑ Ìï¥Î≥¥ÏÑ∏Ïöî!",
                  imageUrl: "/child/character/againCh.png",
                  imageWidth: 200,
                  imageHeight: 200,
                  timer: 3000,
                  showConfirmButton: false
                }).then(() => {
                  console.log("[useEffect - analysisResult] Îã§Ïãú Ïó∞Ïäµ Î™®Îã¨ ÏôÑÎ£å, cycle Î≥ÄÍ≤Ω -> 2");
                  setAnalysisCycle(2);
                  setFaceResult(null);
                  setVoiceResult(null);
                  setPhase("analysisModal");
                });
              }
            } else if (analysisCycle === 2) {
              Swal.fire({
                title: "Ïù¥Ï†ú ÌëúÏ†ï Ïó∞ÏäµÏùÑ Ìï¥Î≥ºÍπåÏöî?",
                text: "Í±∞Ïö∏ÏùÑ Î≥¥Î©¥ÏÑú Ï≤úÏ≤úÌûà Îî∞ÎùºÌï¥Î≥¥ÏÑ∏Ïöî!",
                imageUrl: "/child/character/againCh.png",
                imageWidth: 200,
                imageHeight: 200,
                timer: 3000,
                showConfirmButton: false
              }).then(() => {
                console.log("[useEffect - analysisResult] Îëê Î≤àÏß∏ Î∂ÑÏÑù ÌõÑ ÌëúÏ†ï Ïó∞Ïäµ, cycle Î≥ÄÍ≤Ω -> 3");
                setAnalysisCycle(3);
                setFaceResult(null);
                setVoiceResult(null);
                setPhase("analysisModal");
              });
            }
          }
        });
      } else if (analysisCycle === 3) {
        Swal.fire({
          title: "ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º",
          html: `<p>${faceResult}</p>`,
          imageUrl: "/child/character/againCh.png",
          imageWidth: 200,
          imageHeight: 200,
          timer: 3000,
          showConfirmButton: false
        }).then(() => {
          console.log("[useEffect - analysisResult] face analysis modal ÏûêÎèô Ï¢ÖÎ£å");
          Swal.fire({
            title: "Ïù¥Ï†ú Îßê Ïó∞ÏäµÏùÑ Ìï¥Î≥ºÍπåÏöî?",
            text: "ÏïÑÎûò Í∏ÄÏûêÎ•º Ï≤úÏ≤úÌûà Îî∞ÎùºÌï¥Î≥¥ÏÑ∏Ïöî!",
            imageUrl: "/child/character/againCh.png",
            imageWidth: 200,
            imageHeight: 200,
            timer: 3000,
            showConfirmButton: false
          }).then(() => {
            console.log("[useEffect - analysisResult] voice practice ÏãúÏûë");
            setAnalysisCycle(4);
            setFaceResult(null);
            setPhase("analysisModal");
          });
        });
      } else if (analysisCycle === 4) {
        Swal.fire({
          title: "Îã§Ïãú Ïó∞ÏäµÌï¥Î≥ºÍπåÏöî?",
          icon: "question",
          showCancelButton: true,
          confirmButtonText: "Ïó∞Ïäµ Îã§ÏãúÌïòÍ∏∞",
          cancelButtonText: "Îã§ÏùåÏúºÎ°ú",
          allowOutsideClick: false
        }).then((result) => {
          if (result.isConfirmed) {
            console.log("[useEffect - analysisResult] 'Îã§ÏãúÌïòÍ∏∞' ÏÑ†ÌÉùÎê®");
            setAnalysisCycle(3);
            setFaceResult(null);
            setVoiceResult(null);
            setPhase("analysisModal");
          } else if (result.dismiss === Swal.DismissReason.cancel) {
            console.log("[useEffect - analysisResult] 'Îã§ÏùåÏúºÎ°ú ÎÑòÏñ¥Í∞ÄÍ∏∞' ÏÑ†ÌÉùÎê®");
            Swal.fire({
              html: `
                <style>
                  .flip-card {
                    perspective: 1000px;
                    width: 200px;
                    height: 300px;
                    margin: 0 auto;
                  }
                  .flip-card-inner {
                    position: relative;
                    width: 100%;
                    height: 100%;
                    text-align: center;
                    transition: transform 0.6s;
                    transform-style: preserve-3d;
                  }
                  .flip-card-front, .flip-card-back {
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    backface-visibility: hidden;
                  }
                  .flip-card-back {
                    transform: rotateY(180deg);
                  }
                </style>
                <div class="flip-card">
                  <div class="flip-card-inner">
                    <div class="flip-card-front">
                      <img src="${currentGameData.cardFront}" alt="card front" style="width: 200px; height: 300px; object-fit: contain;" />
                    </div>
                    <div class="flip-card-back">
                      <img src="${currentGameData.cardBack}" alt="card back" style="width: 200px; height: 300px; object-fit: contain;" />
                    </div>
                  </div>
                </div>
              `,
              showConfirmButton: false,
              timer: 2000,
              didOpen: () => {
                setTimeout(() => {
                  const card = document.querySelector(".flip-card-inner");
                  card.style.transform = "rotateY(180deg)";
                }, 4000);
              }
            }).then(() => {
              if (currentGameData.gameStageId === 5) {
                Swal.fire({
                  title: "Ï†ïÎßê ÏûòÌñàÏñ¥Ïöî!",
                  text: "Î™®Îì† Îã®ÏõêÏùÑ ÏôÑÎ£åÌñàÏñ¥Ïöî!",
                  imageUrl: "/child/character/againCh.png",
                  imageWidth: 200,
                  imageHeight: 200,
                  showConfirmButton: true,
                });
              } else {
                Swal.fire({
                  title: "Ï†ïÎßê ÏûòÌñàÏñ¥Ïöî!",
                  text: "Îã§Ïùå Îã®ÏõêÏúºÎ°ú Ïù¥ÎèôÌï†ÍπåÏöî?",
                  imageUrl: "/child/character/againCh.png",
                  imageWidth: 200,
                  imageHeight: 200,
                  timer: 3000,
                  showConfirmButton: false,
                }).then(async () => {
                  console.log("[useEffect - analysisResult] NextChapter Ìò∏Ï∂ú (ÏûêÎèô)");
                  await NextChapter();
                  console.log("[useEffect - analysisResult] NextChapter ÏôÑÎ£å, cycle Ï¥àÍ∏∞Ìôî");
                  setAnalysisCycle(1);
                  setFaceResult(null);
                  setVoiceResult(null);
                  setPhase("video");
                });
              }
            });
          }
        });
      }
    }
  }, [phase, analysisCycle, faceResult, voiceResult, currentGameData?.gameStageId]);

  const StopVideo = () => {
    console.log("[StopVideo] Ìò∏Ï∂úÎê® - ÎπÑÎîîÏò§ Ïû¨ÏÉù/Ï†ïÏßÄ ÌÜ†Í∏Ä Î∞è Î∂ÑÏÑù Ï§ëÏßÄ");
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
        setIsPlaying(false);
        console.log("[StopVideo] ÎπÑÎîîÏò§ Ï†ïÏßÄ");
      } else {
        videoRef.current.play();
        setIsPlaying(true);
        console.log("[StopVideo] ÎπÑÎîîÏò§ Ïû¨ÏÉù");
      }
    }
    if (analysisIntervalRef.current) {
      clearInterval(analysisIntervalRef.current);
      analysisIntervalRef.current = null;
      console.log("[StopVideo] ÏßÑÌñâ Ï§ëÏù∏ Î∂ÑÏÑù Ïù∏ÌÑ∞Î≤å Ï§ëÏßÄ");
    }
  };

  const NextChapter = async () => {
    console.log("[NextChapter] Ìò∏Ï∂úÎê® - Îã§Ïùå Îã®ÏõêÏúºÎ°ú Ïù¥Îèô");
    const nextStageId = currentGameData.gameStageId + 1;
    console.log("[NextChapter] ÌòÑÏû¨ Îã®Ïõê:", currentGameData.gameStageId, "Îã§Ïùå Îã®Ïõê:", nextStageId);
    if (nextStageId > 5) {
      Swal.fire({
        title: `${currentGameData.chapterId}Îã®Í≥Ñ ÎßàÏßÄÎßâÏù¥ÏóêÏöî!`,
        imageUrl: "/child/character/againCh.png",
        imageWidth: 200,
        imageHeight: 200,
        confirmButtonText: "ÌôïÏù∏"
      });
      console.log("[NextChapter] ÎßàÏßÄÎßâ Îã®Ïõê ÎèÑÎã¨ - Ïù¥Îèô Î∂àÍ∞Ä");
      return;
    }
    setChapterAndStage(currentGameData.chapterId, nextStageId);
    console.log("[NextChapter] Îã®Ïõê ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏:", currentGameData.chapterId, nextStageId);
    const gameData = await useGameStore.getState().getCurrentGameData();
    console.log("[NextChapter] ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞:", gameData);
    setCurrentGameData(gameData);
    setPhase("video");
    setAnalysisCycle(1);
    setIsPlaying(false);
  };

  const PrevChapter = async () => {
    console.log("[PrevChapter] Ìò∏Ï∂úÎê® - Ïù¥Ï†Ñ Îã®ÏõêÏúºÎ°ú Ïù¥Îèô");
    const prevStageId = currentGameData.gameStageId - 1;
    console.log("[PrevChapter] ÌòÑÏû¨ Îã®Ïõê:", currentGameData.gameStageId, "Ïù¥Ï†Ñ Îã®Ïõê:", prevStageId);
    if (prevStageId > 0) {
      setChapterAndStage(currentGameData.chapterId, prevStageId);
      console.log("[PrevChapter] Îã®Ïõê ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏:", currentGameData.chapterId, prevStageId);
    }
    const gameData = await useGameStore.getState().getCurrentGameData();
    console.log("[PrevChapter] ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞:", gameData);
    setCurrentGameData(gameData);
    setPhase("video");
    setAnalysisCycle(1);
    setIsPlaying(false);
  };

  return (
      <div className="ch-review-container">
        {/* ÏôºÏ™Ω: Í≤åÏûÑ ÎèôÏòÅÏÉÅ ÏòÅÏó≠ */}
        <div className="ch-review-game-left">
          <Card className="ch-game-screen-container">
            {currentGameData ? (
                <>
                  <h2>
                    {currentGameData?.chapterId ?? ""}Îã®Í≥Ñ {currentGameData?.gameStageId ?? ""}Îã®Ïõê
                  </h2>
                  <h3>{currentGameData?.situation ?? ""}</h3>
                  <video
                      ref={videoRef}
                      src={currentGameData?.gameVideo ?? ""}
                      onEnded={handleVideoEnd}
                      className="ch-gameVideo"
                  />
                  <Card className="ch-learning-message-screen">
                    <div className="learning-message">
                      {phase === "analysis" && <h3>Î∂ÑÏÑù Ï§ëÏûÖÎãàÎã§...</h3>}
                      {phase === "analysisResult" &&
                          analysisCycle > 2 &&
                          analysisCycle !== 1 &&
                          analysisCycle !== 2 && (
                              <div>
                                {analysisCycle === 3 ? (
                                    <h3>ÌëúÏ†ï Î∂ÑÏÑù Í≤∞Í≥º: {faceResult}</h3>
                                ) : analysisCycle === 4 ? (
                                    <h3>ÏùåÏÑ± Î∂ÑÏÑù Í≤∞Í≥º: {voiceResult}</h3>
                                ) : null}
                              </div>
                          )}
                    </div>
                  </Card>
                  <div className="ch-game-button">
                    {currentGameData?.optionImages?.length > 0 &&
                    currentGameData?.options?.length > 0 ? (
                        <div className="option-images">
                          {currentGameData.optionImages.map((imgSrc, index) => (
                              <div key={index} className="learning-option-item">
                                <img src={imgSrc} alt={`option ${index + 1}`} className="option-image" />
                                <p className={`${
                                    analysisCycle < 3
                                        ? index + 1 === currentGameData?.answer ? "ch-learning-before-answer" : ""
                                        : index + 1 === currentGameData?.answer ? "ch-learning-correct-answer" : ""
                                }`}>
                                  {currentGameData.options[index]}
                                </p>
                              </div>
                          ))}
                        </div>
                    ) : (
                        <p>ÏÑ†ÌÉùÏßÄ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
                    )}
                  </div>
                </>
            ) : (
                <h2>Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</h2>
            )}
          </Card>
        </div>

        {/* Ïò§Î•∏Ï™Ω: ÏïÑÎèô ÏõπÏ∫† Î∞è ÏÉÅÎã¥ÏÇ¨ ÌôîÎ©¥ ÏòÅÏó≠ */}
        <div className="ch-review-game-right">
          <div className="ch-game-face-screen">
            <Card className="ch-game-Top-section">
              {/* ÏïÑÎèô ÏõπÏ∫† ÏòÅÏÉÅ: ÏùºÎ∞ò ÏõπÏ∫†ÏúºÎ°ú getUserMedia ÏÇ¨Ïö© */}
              <video ref={childWebcamRef} autoPlay muted style={{ width: "100%" }} />
            </Card>
            <div className="ch-learning-middle-section"></div>
            <div className="ch-learning-bottom-section">
              <div className="ch-learning-button-left">
                <img src="/child/button-left.png" alt="button-left" onClick={PrevChapter} />
                <p> Ïù¥Ï†Ñ Îã®Ïõê</p>
              </div>
              {/* Ïò§Î•∏Ï™Ω: ÏÉÅÎã¥ÏÇ¨ ÌôîÎ©¥ ÏòÅÏó≠ (ÌôîÎ©¥ Í≥µÏú† Ïä§Ìä∏Î¶ºÏùÄ ÏÉÅÎã¥ÏÇ¨ ÌéòÏù¥ÏßÄÏóêÏÑú Íµ¨ÎèÖÎê®) */}
              <Card className="ch-learning-counselor-screen">
                <CounselorCamWithChild session={session} subscriber={subscriber} mode="subscribe" />
              </Card>
              <div className="ch-learning-button-right">
                <img src="/child/button-right.png" alt="button-right" onClick={NextChapter} />
                <p>Îã§Ïùå Îã®Ïõê</p>
                <BsStopBtnFill onClick={StopVideo} className="ch-learning-stop-icon" />
                <button onClick={startScreenShare} disabled={screenSubscriber !== null} className="game-screen-share-button">
                  {screenSubscriber ? "ÌôîÎ©¥ Í≥µÏú† Ï§ë" : "Í≤åÏûÑ ÌôîÎ©¥ Í≥µÏú†ÌïòÍ∏∞"}
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
  );
}

export default ChildReviewGamePage;
